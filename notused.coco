import attr

from utilities import Vector2D

@attr.s(frozen=True)
class Box:
    p1 = attr.ib()
    p2 = attr.ib()

    @classmethod
    def from_p_dim(cls, p, dim):
        return cls(p, p + dim)

    @property
    def l(self) = min(self.p1.x, self.p2.x)
    @property
    def d(self) = min(self.p1.y, self.p2.y)
    @property
    def r(self) = max(self.p1.x, self.p2.x)
    @property
    def u(self) = max(self.p1.y, self.p2.y)
    @property
    def ld(self) = Vector2D(self.l, self.d)
    @property
    def rd(self) = Vector2D(self.r, self.d)
    @property
    def lu(self) = Vector2D(self.l, self.u)
    @property
    def ru(self) = Vector2D(self.r, self.u)
    
    @property
    def width(self) = self.r - self.l
    @property
    def height(self) = self.u - self.d

    @property
    def dim(self) = self.ru - self.ld

    @property
    def is_flipped_x(self) = self.p1.x > self.p2.x
    @property
    def is_flipped_y(self) = self.p1.y > self.p2.y
    def flip_x(self) = type(self)(Vector2D(self.p2.x, self.p1.y), Vector2D(self.p1.x, self.p2.y))
    def flip_y(self) = type(self)(Vector2D(self.p1.x, self.p2.y), Vector2D(self.p2.x, self.p1.y))
    
    def change_u(self, new) = type(self)(self.ld, Vector2D(self.r, new))
    def change_r(self, new) = type(self)(self.ld, Vector2D(new, self.u))
    def change_d(self, new) = type(self)(Vector2D(self.l, new), self.ru)
    def change_l(self, new) = type(self)(Vector2D(new, self.d), self.ru)

    def translate(self, vec):
        return type(self)(self.p1 + vec, self.p2 + vec)
    
    def apply_matrix(self, mati, matj):
        return type(self)(
            self.p1.apply_matrix(mati, matj),
            self.p2.apply_matrix(mati, matj)
        )
    
    def affine_transform(self, mati, matj, translation):
        return self.apply_matrix(mati, matj).translate(translation)
    
    def affine_transform_with_origin(self, origin, *args, **kwargs):
        return self.translate(-origin).affine_transform(*args, **kwargs) + origin
    
    def rotate(self, degrees is int, origin=Vector2D(0, 0)):
        degrees = degrees % 360
        case degrees:
            match 0:
                return self
            match 90:
                return self.affine_transform_with_origin(origin, Vector2D(0, 1), Vector2D(-1, 0))
            match 180:
                return self.affine_transform_with_origin(origin, Vector2D(-1, 0), Vector2D(0, -1))
            match 270:
                return self.affine_transform_with_origin(origin, Vector2D(0, -1), Vector2D(1, 0))
        else:
            raise ValueError("degrees must be multiples of 90")

    def scale(self, x, y, origin=Vector2D(0, 0)) =
        self.affine_transform_with_origin(origin, Vector2D(x, 0), Vector2D(0, y))

@attr.s(frozen=True)
class Affine:
    mati = attr.ib()
    matj = attr.ib()
    translation = attr.ib()

    def __mul__(self, other is Affine) = 
        Affine(
            self.mati.apply_matrix(other.mati, other.matj),
            self.matj.apply_matrix(other.mati, other.matj),
            self.translation.apply_matrix(other.mati, other.matj) + other.translation
        )

    def apply_to(self, vector) = vector.affine_transform(self.mati, self.matj, self.translation)

@attr.s
class Layout:
    outer_box = attr.ib(kw_only=True, default=None)

    def repos(self, new_box=None):
        self.outer_box = new_box ?? self.outer_box

@attr.s
class SingleChildLayout(Layout):
    child = attr.ib()

    def repos(self, new_box=None):
        super().repos(new_box)
        self.child.repos(self.inner_box())

@attr.s
class MultiChildLayout(Layout):
    children = attr.ib()

    def repos(self, new_box=None):
        super().repos(self, new_box)
        for cell_index, child in self.children.items():
            self.child.repos(self.inner_box(cell_index))

@attr.s
class PageReference(Layout):
    referent = attr.ib()
    referent_box = attr.ib()

@attr.s
class AbsMarginLayout(SingleChildLayout):
    margin_l = attr.ib(default=0)
    margin_d = attr.ib(default=0)
    margin_r = attr.ib(default=0)
    margin_u = attr.ib(default=0)

    def inner_box(self) = 
        (self.outer_box
            |> .change_l(self.outer_box.l + self.margin_l)
            |> .change_d(self.outer_box.d + self.margin_d)
            |> .change_r(self.outer_box.r - self.margin_r)
            |> .change_u(self.outer_box.u - self.margin_u)
        )

@attr.s
class RelMarginLayout(SingleChildLayout):
    margin_l = attr.ib(default=0)
    margin_d = attr.ib(default=0)
    margin_r = attr.ib(default=0)
    margin_u = attr.ib(default=0)

    def inner_box(self) = 
        (self.outer_box
            |> .change_l(self.outer_box.l + self.margin_l * self.outer_box.width)
            |> .change_d(self.outer_box.d + self.margin_d * self.outer_box.width)
            |> .change_r(self.outer_box.r - self.margin_r * self.outer_box.height)
            |> .change_u(self.outer_box.u - self.margin_u * self.outer_box.height)
        )

@attr.s
class AspectRatioLayout(SingleChildLayout):
    intrinsic_dim = attr.ib(default=Vector2D(1, 1))
    align = attr.ib(default=Vector2D(0, 0))

    def inner_box(self):
        width, height = self.outer_box.dim
        # try stretching in x direction
        factor = width / self.intrinsic_dim.x
        if factor * self.intrinsic_dim.y > height:
            # stretch in y direction instead
            factor = width / self.intrinsic_dim.x
        inner_width, inner_height = self.intrinsic_dim.x * factor, self.intrinsic_dim.y * factor
        padding_width, padding_height = width - inner_width, height - inner_height
        align_multiplier = align * 2 - Vector2D(1, 1)
        offset_x, offset_y = padding_width * align_multiplier.x, padding_height * align_multiplier.y
        return Box.from_p_dim(
            outer_box.ld + Vector2D(offset_x, offset_y),
            Vector2D(inner_width, inner_height)
        ).flip_x(self.outer_box.is_flipped_x).flip_y(self.outer_box.is_flipped_y)

@attr.s
class GridLayout(MultiChildLayout):
    division = attr.ib(default=Vector2D(2, 2))

    def cell_dim(self) = Vector2D(
        self.outer_box.dim.x / self.division.x,
        self.outer_box.dim.y / self.division.y
    )

    def inner_box(self, cell_index):
        offset = cell_index * self.cell_dim()
        return Box.from_p_dim(
            self.outer_box.p1 + offset,
            self.cell_dim
        )

@attr.s
class TransformLayout(SingleChildLayout):
    transform = attr.ib(factory=list)

    def inner_box(self):
        box = self.outer_box
        for transform_name, *transform_args in self.transform:
            box = (box `getattr` transform_name)(*transform_args)
        return box


