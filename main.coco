from silver_booklet import *
from pikepdf import Pdf, Page, Rectangle, Object, Name, PdfMatrix
import pikepdf
from io import BytesIO

def affine_to_pdf_matrix(affine):
    return PdfMatrix(
        affine.mati.x, affine.mati.y,
        affine.matj.x, affine.matj.y,
        affine.translation.x, affine.translation.y,
    )
pdf_unit_to_mm = 1 / 72 * 25.4
mm_to_pdf_unit = 1 / 25.4 * 72

def add_page_to_pdf(pdf, page_index, region, back_mirror_x=False, back_mirror_y=False):
    destination_page = Page(pdf.pages[region.paper.meta["index"] + original_page_amount])
    thumbnail = Page(pdf.pages[page_index])
    #print(region.paper.meta["index"] + original_page_amount, page_index)
    formx = thumbnail.as_form_xobject(True)
    formx_placed_name = destination_page.add_resource(formx, Name.XObject)
    formx = destination_page.calc_form_xobject_placement(formx, formx_placed_name, Rectangle(0, 0, 300, 300), allow_shrink=True, allow_expand=True)
    #print(formx)
    commands = []
    for operands, operator in pikepdf.parse_content_stream(pdf.make_stream(formx)):
        commands.append([operands, operator])
    #print(Affine.from_scale(Vector2D(page_w, page_h)).inverse() * region.affine * mm_to_pdf_unit)
    region_affine = region.affine
    region_affine *= Affine.from_translation(-region.paper.intrinsic_dim * 0.5) * Affine.from_scale(Vector2D(-1 if back_mirror_x else 1, -1 if back_mirror_y else 1))  * Affine.from_translation(region.paper.intrinsic_dim * 0.5)
    af = Affine.from_scale(Vector2D(page_w_pdf_unit, page_h_pdf_unit)).inverse() * region_affine * mm_to_pdf_unit
    transformed = affine_to_pdf_matrix(af)
    #print(transformed)
    commands[1][0] = pikepdf.Array([*transformed.shorthand])
    new_content_stream = pikepdf.unparse_content_stream(commands)
    #print(new_content_stream)
    destination_page.contents_add(new_content_stream)

PDF_FILE = "test.pdf"

pdf = Pdf.open(PDF_FILE)
page_w_pdf_unit, page_h_pdf_unit = (pdf.pages[0].mediabox |> list)[2:4] |> map$(float)
page_w, page_h = (page_w_pdf_unit, page_h_pdf_unit) |> map$((*)$(pdf_unit_to_mm))
#print(page_w, page_h)
original_page_amount = len(pdf.pages)

ex = PaperCuttingProcessExecuter(
    open("inst.txt").read().split(" "),
    page_manager=PaperCuttingPageManager(original_page_amount, Vector2D(page_w, page_h)),
    paper_manager=PaperCuttingPaperManager(Vector2D(210, 297))
)
ex.execute_all()
paper_amount = ex.paper_manager.generated_paper |> map$(.meta ..> .["index"]) |> max
paper_amount += 1
paper_dims = [None] * paper_amount
for paper in ex.paper_manager.generated_paper:
    paper_dims[paper.meta["index"]] = paper.intrinsic_dim

for front_side in (True, False):
    pdf = Pdf.open(PDF_FILE)
    for i, dim in paper_dims |> enumerate:
        pdf.add_blank_page(page_size=dim.tuple |> map$((*)$(mm_to_pdf_unit)))

    for print_index, region in ex.page_manager.prints.items():
        if region.isfront != front_side:
            continue
        if print_index < original_page_amount:
            print(f"this is frontside{front_side}, now adding source page{print_index}")
            print(region)
            try:
                add_page_to_pdf(pdf, print_index, region, back_mirror_x=not front_side)
            except IndexError:
                print("no more pages")

    del pdf.pages[:original_page_amount]

    pdf.save(if front_side then "front.pdf" else "back.pdf")
    #print(ex.basket.hand.placement[0])
    #print(ex.op_stack)
    #print(ex.page_manager.prints)

"""
def polygon_from_affine(affine):
    v = [Vector2D(0, 0), Vector2D(1, 0), Vector2D(1, 1), Vector2D(0, 1)] |> map$(affine.apply_to)
    return v |> map$(.tuple)

import matplotlib.pyplot as plt
from matplotlib.patches import Polygon

#define Matplotlib figure and axis
fig, ax = plt.subplots()

ax.add_patch(Polygon(polygon_from_affine(ex.basket.hand.placement[0].front.placement_affine), fill=False, edgecolor="pink"))
ax.add_patch(Polygon(polygon_from_affine(ex.page_manager.print_affine), fill=False, edgecolor="blue"))
ax.add_patch(Polygon(polygon_from_affine(ex.page_manager.prints[0].affine), fill=False, edgecolor="orange"))

ax.set_aspect('equal', 'box')
ax.set(xlim=(-0, 600), ylim=(-300, 300))
#display plot
plt.show()
"""
