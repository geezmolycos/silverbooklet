from silver_booklet import *
from pikepdf import Pdf, Page, Rectangle, Object, Name, PdfMatrix
import pikepdf
from io import BytesIO
import argparse
import os
import re

parser = argparse.ArgumentParser(description="Silver booklet command line interface.")
parser.add_argument("input_file", help="Source pdf file to be processed.")
parser.add_argument(
    "-o", "--output",
    help="Output file name. If page arrangement is set to 'file', then suffix '_front' and '_back' will be added."
)
parser.add_argument(
    "-p", "--preset",
    help="Get instruction sequence from a preset file."
)
parser.add_argument(
    "-c", "--code",
    help="Get instruction sequence from command line argument. Takes precedence over '--preset'."
)
parser.add_argument(
    "--arg-preset",
    help="Load instruction arguments (pre-applying code) from file."
)
parser.add_argument(
    "--args",
    help="Load instruction arguments (pre-applying code) from string."
)
parser.add_argument(
    "--arrange",
    choices=["f", "s", "i", "1", "2"],
    default="f",
    help=
    """Output page arrangement for double-sided output.
    'f'(default): split front and back to 2 files.
    's': sequential, first front, then back.
    'i': interlaced, take one page of front, then one of back.
    '1': front only.
    '2': back only.
    """
)
parser.add_argument(
    "--arrange-flip",
    choices=["n", "x", "y", "xy"],
    default="x",
    help="Page flip direction for back side.('n' stands for no flip, default 'x')"
)

args = parser.parse_args()

back_mirror_x = args.arrange_flip in ("x", "xy")
back_mirror_y = args.arrange_flip in ("y", "xy")


def file_name_suffix(file_name, suffix):
    f, e = os.path.splitext file_name
    return f + suffix + e

def affine_to_pdf_matrix(affine):
    return PdfMatrix(
        affine.mati.x, affine.mati.y,
        affine.matj.x, affine.matj.y,
        affine.translation.x, affine.translation.y,
    )
pdf_unit_to_mm = 1 / 72 * 25.4
mm_to_pdf_unit = 1 / 25.4 * 72

def add_thumbnail(from_page, dest_page, region, back_mirror_x=False, back_mirror_y=False):
    #print(region.paper.meta["index"] + original_page_amount, page_index)
    formx = from_page.as_form_xobject(True)
    formx_placed_name = dest_page.add_resource(formx, Name.XObject)
    formx = dest_page.calc_form_xobject_placement(formx, formx_placed_name, Rectangle(0, 0, 300, 300), allow_shrink=True, allow_expand=True)
    #print(formx)
    commands = []
    for operands, operator in pikepdf.parse_content_stream(pdf.make_stream(formx)):
        commands.append([operands, operator])
    #print(Affine.from_scale(Vector2D(page_w, page_h)).inverse() * region.affine * mm_to_pdf_unit)
    region_affine = region.affine
    region_affine *= Affine.from_translation(-region.paper.intrinsic_dim * 0.5) * Affine.from_scale(Vector2D(-1 if back_mirror_x else 1, -1 if back_mirror_y else 1))  * Affine.from_translation(region.paper.intrinsic_dim * 0.5)
    af = Affine.from_scale(Vector2D(page_w_pdf_unit, page_h_pdf_unit)).inverse() * region_affine * mm_to_pdf_unit
    transformed = affine_to_pdf_matrix(af)
    #print(transformed)
    commands[1][0] = pikepdf.Array([*transformed.shorthand])
    new_content_stream = pikepdf.unparse_content_stream(commands)
    #print(new_content_stream)
    dest_page.contents_add(new_content_stream)

pdf_input_file = args.input_file

pdf = Pdf.open(pdf_input_file)
page_w_pdf_unit, page_h_pdf_unit = (pdf.pages[0].mediabox |> list)[2:4] |> map$(float)
page_w, page_h = (page_w_pdf_unit, page_h_pdf_unit) |> map$((*)$(pdf_unit_to_mm))
#print(page_w, page_h)
original_page_amount = len(pdf.pages)

pre_code = (args.args |?> re.split$(" |\n")) ?? (args.arg_preset |?> open |?> .read() |?> re.split$(" |\n"))
code = (args.code |?> re.split$(" |\n")) ?? (args.preset |?> open |?> .read() |?> re.split$(" |\n"))

pre_code ??= []
if code is None:
    raise ValueError("no code available, check if -p or -c is preset")

ex = PaperCuttingProcessExecuter(
    pre_code + code,
    page_manager=PaperCuttingPageManager(original_page_amount, Vector2D(page_w, page_h)),
    paper_manager=PaperCuttingPaperManager(Vector2D(210, 297))
)
ex.execute_all(debug_output=False)
try:
    paper_amount = ex.paper_manager.generated_paper |> map$(.meta ..> .["index"]) |> max
except ValueError as e:
    raise ValueError("no page generated by code") from e
paper_amount += 1
paper_dims = [None] * paper_amount
for paper in ex.paper_manager.generated_paper:
    paper_dims[paper.meta["index"]] = paper.intrinsic_dim

target_papers_in_pdf = {}

case args.arrange:
    match "f":
        front_file = Pdf.open(pdf_input_file)
        back_file = Pdf.open(pdf_input_file)
        for paper_index, paper_dim in paper_dims |> enumerate:
            fp, bp = [front_file, back_file] |> map$(-> _.add_blank_page(page_size=paper_dim.tuple |> map$((*)$(mm_to_pdf_unit))))
            target_papers_in_pdf[paper_index] = (fp, bp)
    match "s":
        output_file = Pdf.open(pdf_input_file)
        for paper_index, paper_dim in paper_dims |> enumerate: # front
            p = output_file.add_blank_page(page_size=paper_dim.tuple |> map$((*)$(mm_to_pdf_unit)))
            target_papers_in_pdf[paper_index] = (p, )
        for paper_index, paper_dim in paper_dims |> enumerate: # back
            p = output_file.add_blank_page(page_size=paper_dim.tuple |> map$((*)$(mm_to_pdf_unit)))
            target_papers_in_pdf[paper_index] += (p, )
    match "i":
        output_file = Pdf.open(pdf_input_file)
        for paper_index, paper_dim in paper_dims |> enumerate: # front
            fp = output_file.add_blank_page(page_size=paper_dim.tuple |> map$((*)$(mm_to_pdf_unit)))
            bp = output_file.add_blank_page(page_size=paper_dim.tuple |> map$((*)$(mm_to_pdf_unit)))
            target_papers_in_pdf[paper_index] = (fp, bp)
    match ("1" | "2") as a:
        output_file = Pdf.open(pdf_input_file)
        for paper_index, paper_dim in paper_dims |> enumerate: # front
            p = output_file.add_blank_page(page_size=paper_dim.tuple |> map$((*)$(mm_to_pdf_unit)))
            target_papers_in_pdf[paper_index] = (p, None) if a == "1" else (None, p)
for print_index, region in ex.page_manager.prints.items():
    is_back = not region.isfront
    if print_index < original_page_amount:
        #print(f"now adding source page{print_index}")
        #print(region)
        try:
            add_thumbnail(pdf.pages[print_index], target_papers_in_pdf[print_index][1 if is_back else 0], region, back_mirror_x=is_back and back_mirror_x, back_mirror_y=is_back and back_mirror_y)
        except IndexError:
            print("no more pages")
case args.arrange:
    match "s" | "i" | "1" | "2":
        del output_file.pages[:original_page_amount]
        output_file.save(args.output ?? file_name_suffix(pdf_input_file, "_output"))
    match "f":
        del front_file.pages[:original_page_amount]
        del back_file.pages[:original_page_amount]
        front_file.save((args.output |?> file_name_suffix$(?, "_front")) ?? file_name_suffix(pdf_input_file, "_front"))
        back_file.save((args.output |?> file_name_suffix$(?, "_back")) ?? file_name_suffix(pdf_input_file, "_back"))


#print(ex.basket.hand.placement[0])
#print(ex.op_stack)
#print(ex.page_manager.prints)

"""
def polygon_from_affine(affine):
    v = [Vector2D(0, 0), Vector2D(1, 0), Vector2D(1, 1), Vector2D(0, 1)] |> map$(affine.apply_to)
    return v |> map$(.tuple)

import matplotlib.pyplot as plt
from matplotlib.patches import Polygon

#define Matplotlib figure and axis
fig, ax = plt.subplots()

ax.add_patch(Polygon(polygon_from_affine(ex.basket.hand.placement[0].front.placement_affine), fill=False, edgecolor="pink"))
ax.add_patch(Polygon(polygon_from_affine(ex.page_manager.print_affine), fill=False, edgecolor="blue"))
ax.add_patch(Polygon(polygon_from_affine(ex.page_manager.prints[0].affine), fill=False, edgecolor="orange"))

ax.set_aspect('equal', 'box')
ax.set(xlim=(-0, 600), ylim=(-300, 300))
#display plot
plt.show()
"""
